/*
ICSI 333. System Fundamentals, Spring 2023
TA: Kazi Kibria
Developer: Joshua Roundy, Student ID: 001518993                            
*/
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/*Returns and parses a double (or real number) that was entered into the terminal by the user.
No parameters.
*/
double getInput()
{
    //str is the string used to store the character values initially stored in ch
    char str[50],ch;
    //the iterator to be used in the while loop below that collects the input from the user.
    int j = 0;
    printf("\nInput a real number:");
    fflush(stdout);
    while(ch!='\n')
    {
        ch = getchar();
        str[j] = ch;
        j++;
    }
    str[j] = '\0';
    /*the end character to be used in the strtod function, in this case it is not pointing to anything because 
    I want the whole string to be parsed.*/
    char *ptr;
   
    return strtod(str,&ptr);
}
/*Converts binary array and given length into a decimal number 
*/
int binaryToDecimal(char array[], int n)
{
    //value is the number that will be added with the powers of 2 , i = counter, multiplier = iterating bitwise shifter
    int value = 0,i, multiplier = 0;  
    for (i = n - 1; i >= 0; i--, multiplier++)  
    {  
     value +=(array[i]) * (1 << multiplier);  
    }  
      
    return value;  

}
/*Converts floating point array into fractional decimal number
*/
double mantissaToDecimal(int *array)
{
    //the decimal that will be added with 2^(neg #)
    double decimal = 0;
    //counter that iterates through all of the ints in the inputted array
    int i;
    for(i = 0;i<32;i++)
    {
        //checks for end of array
        if(array[i] == -1) break;
        if(array[i]==1)
        {
            decimal += pow(2,-1*i);
        }
    }
    return decimal;
}
/* Restores the number that was converted to ieee 754 format
*/
float restore(int *array)
{
    //boolean if the number is negative
    int isNegative = array[0];
    //the array that holds the exponent binary
    char exponentArray[8] = {0};
    
//maps the exponent binary to the array just made
    for(int i =1;i<9;i++)
    {
        exponentArray[i-1] = array[i]; 
    }

    //exponent will be mapped
    int exponent = -1*((127)-binaryToDecimal(exponentArray,8));
    //array that will store the mantissa including the starting 1
    int mantissa[24];
    //sets the mantissa array to its value from the input array
    for(int i = 1;i<24;i++)
    {
        mantissa[i] = array[i+8];
    }
    mantissa[0] =1;
    //checks if the exponent is negative which means the number is a fraction
    int isNegativeExponent  = 0;
    //array to hold the binary for the whole portion
    char mantissaWholeArray[64];
    //array to hold the mantissa (the fractional part)
    int mantissaDecimalArray[64];
    
    if(exponent >0)
    {
      //add the characters until the exponent to the whole array then add the remaining to the mantissa array, no added zeros needed
      //counter used several times
      int i;
      exponent++;
      for(i = 0;i<exponent;i++)
      {
        mantissaWholeArray[i] = mantissa[i];
       // printf("\n");
       // printf("%hhu",mantissaWholeArray[i]);
      }  
      //the converted whole part of the number
      int whole = binaryToDecimal(mantissaWholeArray,exponent);
        //counter that continues from where i left off
        int j;
        mantissaDecimalArray[0] = 0;mantissaDecimalArray[1] = 0;
        for(j = i;j<24;j++)
        {
            mantissaDecimalArray[j-i+1] = mantissa[j];
        }
        mantissaDecimalArray[j-i+2] = -1;
        //the fractional part of the converted number
        double fraction = mantissaToDecimal(mantissaDecimalArray);
        double val = ((double)whole)+fraction;
        if(isNegative) val *= -1;
        return val;

    } else {
        //counter
        int i;
        for(i = 0;i<-1*exponent;i++)
            mantissaDecimalArray[i] = 0;
        //counter that picks off from where i left off and is used to add the mantissa which is all decimal in this case
        int j;
        for(j = i;j-i<24;j++)
        mantissaDecimalArray[j] = mantissa[j-i];
        
        mantissaDecimalArray[j+1] = -1; 
        //the fractional value generated by the mantissa
        double val = mantissaToDecimal(mantissaDecimalArray);
        if(isNegative) val *= -1;
        return val;
    }
    
    
}

/*
Returns a pointer to an array of binary that is equivalent to the decimal number inputted.
int decimalNumber : the decimal number inputted to be returned as a binary array
*/
int * convertToBinary(int decimalNumber)
{
    //in the case of 0 or 1 it returns the proper array as the code below does not function properly for small numbers
    if(decimalNumber ==0||decimalNumber==1)
    {
        static int simpleArray[32];
        simpleArray[0]=decimalNumber;
        for(int i = 0;i<32;i++)
        simpleArray[i]=-1;
        return simpleArray;
    }
    //the integer array of the reverse order binary generated by the loop below
    int binaryArray[32];
    //counter to be used in the loop then later as a reference to fix the reversed order of the first array
    int i;
    for(i =0;decimalNumber>0;i++)
    {
        binaryArray[i] = decimalNumber%2;
        decimalNumber = decimalNumber/2;
    }
    //the array that will store the proper order binary and later be returned.
    static int finalArray[32]={-1};
    //reverses the order of the first and stores it in the 2nd, then fills the remaining slots with -1
    for(int j = --i;j>=0;j--)
    finalArray[j] = binaryArray[i-j];
    for(int k = i+1;k<24;k++)
    finalArray[k] = -1;

    return finalArray;
}

/* Converts a user inputted double into IEEE-754 single precision binary floating point format
Does all of the things essential to the program that would otherwise be awkward/inefficient to turn into functions.
No parameters.
*/
int * convertToIEEE754(double input,int output[32])
{
    //the double inputted by the user
    //double input = getInput();
    //boolean for if the input is negative or not.
    int isNegative = 0;
    //checks if input was negative and adjusts its value and isNegative accordingly
    if(input < 0){
        isNegative = 1;
        input = -1*input;}
    //the integer portion of the input to be converted to binary
    int integerNum = (int)input;
    //the fractional portion of the input to be converted to mantissa
    double fractionNum = input-integerNum;
    //value for the exponent to be declared and converted to binary later
    int exponent = 0;
    //pointer to array converted from the decimal value of the exponent
    int *exponentBinary;
    //pointer to array converted from the decimal value of the integer portion of the input
    int *mantissaInt;
    //array used to store the mantissa converted fractional portion of the input
    int mantissaFract[32] = {-1};
    //used to store the combined values of the mantissa int and fraction, will be shifted to find the exponent
    int mantissaCombined[64] = {0};

    //the output array which will hold the finalized 4 byte single precision float
    //int *output = malloc(32);

    
   
   //mantissa binary int generation
   mantissaInt = convertToBinary(integerNum);
    
    //mantissa fraction generation
    int finished = 0;
    
   for(int i = 0;i<32;i++)
    {
        if(fractionNum == 0.0) finished = 1;
        if(finished==0)
        {
            fractionNum = fractionNum*2;
            if(fractionNum >= 1)
            {
            mantissaFract[i]=1;
            fractionNum--;
            }
            else mantissaFract[i] = 0;
        } else break;
    }
    //concatenate
    //127+i-1 serves as the exponent
    //counter used to find the exponent
    int i = 0;
    if(input>=1&&input<2)
    {
        i = 1;
        for(int j = 0;j<32;j++)
        {
            if(mantissaFract[j] == -1) break;
            mantissaCombined[j+1] = mantissaFract[j];
        }
    }
    else if(input>=1){
        for( i=0;i<32;i++)
        {
            if(*(mantissaInt + i) == -1) break;
            mantissaCombined[i]=*(mantissaInt + i);
        }
        int j;
        for(j = 0;j<32;j++)
        {
            if(mantissaFract[j] == -1) break;
            mantissaCombined[i+j]=mantissaFract[j];
        }
    }else {
        //used in state machine in the case the one has been found or not.
        int oneFound = 0;
        for(int s =0;s<32;s++)
        {
            if(!oneFound)
            {
                if(mantissaFract[s] == 1)
                {
                oneFound = 1;
                s--;
                }
                else i--;
            } else {
                mantissaCombined[s+i] = mantissaFract[s];
            }

        }
    }
    exponent = 126+i;

    //get exponent binary
    //if(i!=0)
    exponentBinary = convertToBinary(exponent);

    // OUTPUT PORTION:
    //in the case the exponent has less than 8 binary digits this will be used to insert zeros before the digits when writing array
    int zeroCounter = 0;
    //checks and increments zeroCounter when zeros are found
    for(int m = 0;m<8;m++)
    if(*(exponentBinary+m) == -1) zeroCounter++;

    output[0] = isNegative;
    int initialZeroCounter = zeroCounter;
    for(i =0;i<8;i++)
    {
        int temp = i-initialZeroCounter;
        if(zeroCounter>0)
        {
            zeroCounter--;
            output[1+i] = 0;
            
        }else output[1+i] = *(exponentBinary + temp);
    }
            if(mantissaCombined[24] == 1)
            {
                if(mantissaCombined[23]==1)
                {
                    int l = 23;
                    exponent++;
                    while(mantissaCombined[l]==1)
                    {
                        mantissaCombined[l] = 0;
                        l--;
                    }
                    mantissaCombined[l] = 1;
                } else mantissaCombined[23] =1;
            }
    for(int i =1;i<24;i++)
        output[8+i]=mantissaCombined[i];
    

   return output;
}
/* Prints the array of IEEE754 format used to bug testing only.
*/
void printIEEE754(int *array)
{
    printf("FORMATTED:\nNEGATIVE: [ %d ]\nEXPONENT: [",array[0]);
    for(int i = 1;i<9;i++)
        printf(" %d",array[i]);

    printf(" ]\nMANTISSA: [ 1");
    for(int i = 9;i<32;i++)
        printf(" %d",array[i]);
    
    printf(" ]\n");
}
//prints the formatted IEEE754 to the file given by a pointer
void printIEEE754ToFile(FILE *fptr, int *array)
{
    fprintf(fptr,"NEGATIVE: [ %d ] EXPONENT: [",array[0]);
    for(int i = 1;i<9;i++)
        fprintf(fptr," %d",array[i]);
09
    fprintf(fptr," ] MANTISSA: [ 1");
    for(int i = 9;i<32;i++)
        fprintf(fptr," %d",array[i]);
    
    fprintf(fptr," ]\n");
}


